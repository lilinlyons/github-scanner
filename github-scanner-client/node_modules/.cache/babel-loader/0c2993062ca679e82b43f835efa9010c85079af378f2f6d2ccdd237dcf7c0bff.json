{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { invariant, newInvariantError } from \"../utilities/globals/index.js\";\nimport { ApolloLink, execute } from \"../link/core/index.js\";\nimport { version } from \"../version.js\";\nimport { HttpLink } from \"../link/http/index.js\";\nimport { QueryManager } from \"./QueryManager.js\";\nimport { LocalState } from \"./LocalState.js\";\nvar hasSuggestedDevtools = false;\n// Though mergeOptions now resides in @apollo/client/utilities, it was\n// previously declared and exported from this module, and then reexported from\n// @apollo/client/core. Since we need to preserve that API anyway, the easiest\n// solution is to reexport mergeOptions where it was previously declared (here).\nimport { mergeOptions } from \"../utilities/index.js\";\nimport { getApolloClientMemoryInternals } from \"../utilities/caching/getMemoryInternals.js\";\nimport { warnRemovedOption } from \"../utilities/deprecation/index.js\";\nexport { mergeOptions };\n/**\n * This is the primary Apollo Client class. It is used to send GraphQL documents (i.e. queries\n * and mutations) to a GraphQL spec-compliant server over an `ApolloLink` instance,\n * receive results from the server and cache the results in a store. It also delivers updates\n * to GraphQL queries through `Observable` instances.\n */\nvar ApolloClient = /** @class */function () {\n  /**\n   * Constructs an instance of `ApolloClient`.\n   *\n   * @example\n   * ```js\n   * import { ApolloClient, InMemoryCache } from '@apollo/client';\n   *\n   * const cache = new InMemoryCache();\n   *\n   * const client = new ApolloClient({\n   *   // Provide required constructor fields\n   *   cache: cache,\n   *   uri: 'http://localhost:4000/',\n   *\n   *   // Provide some optional constructor fields\n   *   name: 'react-web-client',\n   *   version: '1.3',\n   *   queryDeduplication: false,\n   *   defaultOptions: {\n   *     watchQuery: {\n   *       fetchPolicy: 'cache-and-network',\n   *     },\n   *   },\n   * });\n   * ```\n   */\n  function ApolloClient(options) {\n    var _this = this;\n    var _a, _b, _c;\n    this.resetStoreCallbacks = [];\n    this.clearStoreCallbacks = [];\n    if (!options.cache) {\n      throw newInvariantError(16);\n    }\n    var uri = options.uri,\n      credentials = options.credentials,\n      headers = options.headers,\n      cache = options.cache,\n      documentTransform = options.documentTransform,\n      _d = options.ssrMode,\n      ssrMode = _d === void 0 ? false : _d,\n      _e = options.ssrForceFetchDelay,\n      ssrForceFetchDelay = _e === void 0 ? 0 : _e,\n      // Expose the client instance as window.__APOLLO_CLIENT__ and call\n      // onBroadcast in queryManager.broadcastQueries to enable browser\n      // devtools, but disable them by default in production.\n      connectToDevTools = options.connectToDevTools,\n      _f = options.queryDeduplication,\n      queryDeduplication = _f === void 0 ? true : _f,\n      defaultOptions = options.defaultOptions,\n      defaultContext = options.defaultContext,\n      _g = options.assumeImmutableResults,\n      assumeImmutableResults = _g === void 0 ? cache.assumeImmutableResults : _g,\n      resolvers = options.resolvers,\n      typeDefs = options.typeDefs,\n      fragmentMatcher = options.fragmentMatcher,\n      clientAwareness = options.clientAwareness,\n      clientAwarenessName = options.name,\n      clientAwarenessVersion = options.version,\n      devtools = options.devtools,\n      dataMasking = options.dataMasking;\n    if (globalThis.__DEV__ !== false) {\n      warnRemovedOption(options, \"connectToDevTools\", \"ApolloClient\", \"Please use `devtools.enabled` instead.\");\n      warnRemovedOption(options, \"uri\", \"ApolloClient\", \"Please initialize an instance of `HttpLink` with `uri` instead.\");\n      warnRemovedOption(options, \"credentials\", \"ApolloClient\", \"Please initialize an instance of `HttpLink` with `credentials` instead.\");\n      warnRemovedOption(options, \"headers\", \"ApolloClient\", \"Please initialize an instance of `HttpLink` with `headers` instead.\");\n      warnRemovedOption(options, \"name\", \"ApolloClient\", \"Please use the `clientAwareness.name` option instead.\");\n      warnRemovedOption(options, \"version\", \"ApolloClient\", \"Please use the `clientAwareness.version` option instead.\");\n      warnRemovedOption(options, \"typeDefs\", \"ApolloClient\");\n      if (!options.link) {\n        globalThis.__DEV__ !== false && invariant.warn(17);\n      }\n    }\n    var link = options.link;\n    if (!link) {\n      link = uri ? new HttpLink({\n        uri: uri,\n        credentials: credentials,\n        headers: headers\n      }) : ApolloLink.empty();\n    }\n    this.link = link;\n    this.cache = cache;\n    this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;\n    this.queryDeduplication = queryDeduplication;\n    this.defaultOptions = defaultOptions || Object.create(null);\n    this.typeDefs = typeDefs;\n    this.devtoolsConfig = __assign(__assign({}, devtools), {\n      enabled: (_a = devtools === null || devtools === void 0 ? void 0 : devtools.enabled) !== null && _a !== void 0 ? _a : connectToDevTools\n    });\n    if (this.devtoolsConfig.enabled === undefined) {\n      this.devtoolsConfig.enabled = globalThis.__DEV__ !== false;\n    }\n    if (ssrForceFetchDelay) {\n      setTimeout(function () {\n        return _this.disableNetworkFetches = false;\n      }, ssrForceFetchDelay);\n    }\n    this.watchQuery = this.watchQuery.bind(this);\n    this.query = this.query.bind(this);\n    this.mutate = this.mutate.bind(this);\n    this.watchFragment = this.watchFragment.bind(this);\n    this.resetStore = this.resetStore.bind(this);\n    this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);\n    this.version = version;\n    this.localState = new LocalState({\n      cache: cache,\n      client: this,\n      resolvers: resolvers,\n      fragmentMatcher: fragmentMatcher\n    });\n    this.queryManager = new QueryManager({\n      cache: this.cache,\n      link: this.link,\n      defaultOptions: this.defaultOptions,\n      defaultContext: defaultContext,\n      documentTransform: documentTransform,\n      queryDeduplication: queryDeduplication,\n      ssrMode: ssrMode,\n      dataMasking: !!dataMasking,\n      clientAwareness: {\n        name: (_b = clientAwareness === null || clientAwareness === void 0 ? void 0 : clientAwareness.name) !== null && _b !== void 0 ? _b : clientAwarenessName,\n        version: (_c = clientAwareness === null || clientAwareness === void 0 ? void 0 : clientAwareness.version) !== null && _c !== void 0 ? _c : clientAwarenessVersion\n      },\n      localState: this.localState,\n      assumeImmutableResults: assumeImmutableResults,\n      onBroadcast: this.devtoolsConfig.enabled ? function () {\n        if (_this.devToolsHookCb) {\n          _this.devToolsHookCb({\n            action: {},\n            state: {\n              queries: _this.queryManager.getQueryStore(),\n              mutations: _this.queryManager.mutationStore || {}\n            },\n            dataWithOptimisticResults: _this.cache.extract(true)\n          });\n        }\n      } : void 0\n    });\n    if (this.devtoolsConfig.enabled) this.connectToDevTools();\n  }\n  Object.defineProperty(ApolloClient.prototype, \"prioritizeCacheValues\", {\n    /**\n     * Whether to prioritize cache values over network results when `query` or `watchQuery` is called.\n     * This will essentially turn a `\"network-only\"` or `\"cache-and-network\"` fetchPolicy into a `\"cache-first\"` fetchPolicy,\n     * but without influencing the `fetchPolicy` of the created `ObservableQuery` long-term.\n     *\n     * This can e.g. be used to prioritize the cache during the first render after SSR.\n     */\n    get: function () {\n      return this.disableNetworkFetches;\n    },\n    set: function (value) {\n      this.disableNetworkFetches = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  ApolloClient.prototype.connectToDevTools = function () {\n    if (typeof window === \"undefined\") {\n      return;\n    }\n    var windowWithDevTools = window;\n    var devtoolsSymbol = Symbol.for(\"apollo.devtools\");\n    (windowWithDevTools[devtoolsSymbol] = windowWithDevTools[devtoolsSymbol] || []).push(this);\n    windowWithDevTools.__APOLLO_CLIENT__ = this;\n    /**\n     * Suggest installing the devtools for developers who don't have them\n     */\n    if (!hasSuggestedDevtools && globalThis.__DEV__ !== false) {\n      hasSuggestedDevtools = true;\n      if (window.document && window.top === window.self && /^(https?|file):$/.test(window.location.protocol)) {\n        setTimeout(function () {\n          if (!window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__) {\n            var nav = window.navigator;\n            var ua = nav && nav.userAgent;\n            var url = void 0;\n            if (typeof ua === \"string\") {\n              if (ua.indexOf(\"Chrome/\") > -1) {\n                url = \"https://chrome.google.com/webstore/detail/\" + \"apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm\";\n              } else if (ua.indexOf(\"Firefox/\") > -1) {\n                url = \"https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/\";\n              }\n            }\n            if (url) {\n              globalThis.__DEV__ !== false && invariant.log(\"Download the Apollo DevTools for a better development \" + \"experience: %s\", url);\n            }\n          }\n        }, 10000);\n      }\n    }\n  };\n  Object.defineProperty(ApolloClient.prototype, \"documentTransform\", {\n    /**\n     * The `DocumentTransform` used to modify GraphQL documents before a request\n     * is made. If a custom `DocumentTransform` is not provided, this will be the\n     * default document transform.\n     */\n    get: function () {\n      return this.queryManager.documentTransform;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Call this method to terminate any active client processes, making it safe\n   * to dispose of this `ApolloClient` instance.\n   */\n  ApolloClient.prototype.stop = function () {\n    this.queryManager.stop();\n  };\n  /**\n   * This watches the cache store of the query according to the options specified and\n   * returns an `ObservableQuery`. We can subscribe to this `ObservableQuery` and\n   * receive updated results through an observer when the cache store changes.\n   *\n   * Note that this method is not an implementation of GraphQL subscriptions. Rather,\n   * it uses Apollo's store in order to reactively deliver updates to your query results.\n   *\n   * For example, suppose you call watchQuery on a GraphQL query that fetches a person's\n   * first and last name and this person has a particular object identifier, provided by\n   * dataIdFromObject. Later, a different query fetches that same person's\n   * first and last name and the first name has now changed. Then, any observers associated\n   * with the results of the first query will be updated with a new result object.\n   *\n   * Note that if the cache does not change, the subscriber will *not* be notified.\n   *\n   * See [here](https://medium.com/apollo-stack/the-concepts-of-graphql-bc68bd819be3#.3mb0cbcmc) for\n   * a description of store reactivity.\n   */\n  ApolloClient.prototype.watchQuery = function (options) {\n    if (this.defaultOptions.watchQuery) {\n      options = mergeOptions(this.defaultOptions.watchQuery, options);\n    }\n    // XXX Overwriting options is probably not the best way to do this long term...\n    if (this.disableNetworkFetches && (options.fetchPolicy === \"network-only\" || options.fetchPolicy === \"cache-and-network\")) {\n      options = __assign(__assign({}, options), {\n        fetchPolicy: \"cache-first\"\n      });\n    }\n    if (globalThis.__DEV__ !== false) {\n      warnRemovedOption(options, \"canonizeResults\", \"client.watchQuery\");\n      warnRemovedOption(options, \"partialRefetch\", \"client.watchQuery\");\n    }\n    return this.queryManager.watchQuery(options);\n  };\n  /**\n   * This resolves a single query according to the options specified and\n   * returns a `Promise` which is either resolved with the resulting data\n   * or rejected with an error.\n   *\n   * @param options - An object of type `QueryOptions` that allows us to\n   * describe how this query should be treated e.g. whether it should hit the\n   * server at all or just resolve from the cache, etc.\n   */\n  ApolloClient.prototype.query = function (options) {\n    if (this.defaultOptions.query) {\n      options = mergeOptions(this.defaultOptions.query, options);\n    }\n    invariant(options.fetchPolicy !== \"cache-and-network\", 18);\n    if (this.disableNetworkFetches && options.fetchPolicy === \"network-only\") {\n      options = __assign(__assign({}, options), {\n        fetchPolicy: \"cache-first\"\n      });\n    }\n    if (globalThis.__DEV__ !== false) {\n      warnRemovedOption(options, \"canonizeResults\", \"client.query\");\n      warnRemovedOption(options, \"notifyOnNetworkStatusChange\", \"client.query\", \"This option does not affect `client.query` and can be safely removed.\");\n      if (options.fetchPolicy === \"standby\") {\n        globalThis.__DEV__ !== false && invariant.warn(19);\n      }\n    }\n    return this.queryManager.query(options);\n  };\n  /**\n   * This resolves a single mutation according to the options specified and returns a\n   * Promise which is either resolved with the resulting data or rejected with an\n   * error. In some cases both `data` and `errors` might be undefined, for example\n   * when `errorPolicy` is set to `'ignore'`.\n   *\n   * It takes options as an object with the following keys and values:\n   */\n  ApolloClient.prototype.mutate = function (options) {\n    if (this.defaultOptions.mutate) {\n      options = mergeOptions(this.defaultOptions.mutate, options);\n    }\n    return this.queryManager.mutate(options);\n  };\n  /**\n   * This subscribes to a graphql subscription according to the options specified and returns an\n   * `Observable` which either emits received data or an error.\n   */\n  ApolloClient.prototype.subscribe = function (options) {\n    var _this = this;\n    var id = this.queryManager.generateQueryId();\n    return this.queryManager.startGraphQLSubscription(options).map(function (result) {\n      return __assign(__assign({}, result), {\n        data: _this.queryManager.maskOperation({\n          document: options.query,\n          data: result.data,\n          fetchPolicy: options.fetchPolicy,\n          id: id\n        })\n      });\n    });\n  };\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL query without making a network request. This method will start at\n   * the root query. To start at a specific id returned by `dataIdFromObject`\n   * use `readFragment`.\n   *\n   * @param optimistic - Set to `true` to allow `readQuery` to return\n   * optimistic results. Is `false` by default.\n   */\n  ApolloClient.prototype.readQuery = function (options, optimistic) {\n    if (optimistic === void 0) {\n      optimistic = false;\n    }\n    return this.cache.readQuery(options, optimistic);\n  };\n  /**\n   * Watches the cache store of the fragment according to the options specified\n   * and returns an `Observable`. We can subscribe to this\n   * `Observable` and receive updated results through an\n   * observer when the cache store changes.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are reading. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   *\n   * @since 3.10.0\n   * @param options - An object of type `WatchFragmentOptions` that allows\n   * the cache to identify the fragment and optionally specify whether to react\n   * to optimistic updates.\n   */\n  ApolloClient.prototype.watchFragment = function (options) {\n    var _a;\n    return this.cache.watchFragment(__assign(__assign({}, options), (_a = {}, _a[Symbol.for(\"apollo.dataMasking\")] = this.queryManager.dataMasking, _a)));\n  };\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL fragment without making a network request. This method will read a\n   * GraphQL fragment from any arbitrary id that is currently cached, unlike\n   * `readQuery` which will only read from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are reading. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   *\n   * @param optimistic - Set to `true` to allow `readFragment` to return\n   * optimistic results. Is `false` by default.\n   */\n  ApolloClient.prototype.readFragment = function (options, optimistic) {\n    if (optimistic === void 0) {\n      optimistic = false;\n    }\n    return this.cache.readFragment(options, optimistic);\n  };\n  /**\n   * Writes some data in the shape of the provided GraphQL query directly to\n   * the store. This method will start at the root query. To start at a\n   * specific id returned by `dataIdFromObject` then use `writeFragment`.\n   */\n  ApolloClient.prototype.writeQuery = function (options) {\n    var ref = this.cache.writeQuery(options);\n    if (options.broadcast !== false) {\n      this.queryManager.broadcastQueries();\n    }\n    return ref;\n  };\n  /**\n   * Writes some data in the shape of the provided GraphQL fragment directly to\n   * the store. This method will write to a GraphQL fragment from any arbitrary\n   * id that is currently cached, unlike `writeQuery` which will only write\n   * from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are writing. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   */\n  ApolloClient.prototype.writeFragment = function (options) {\n    var ref = this.cache.writeFragment(options);\n    if (options.broadcast !== false) {\n      this.queryManager.broadcastQueries();\n    }\n    return ref;\n  };\n  ApolloClient.prototype.__actionHookForDevTools = function (cb) {\n    this.devToolsHookCb = cb;\n  };\n  ApolloClient.prototype.__requestRaw = function (payload) {\n    return execute(this.link, payload);\n  };\n  /**\n   * Resets your entire store by clearing out your cache and then re-executing\n   * all of your active queries. This makes it so that you may guarantee that\n   * there is no data left in your store from a time before you called this\n   * method.\n   *\n   * `resetStore()` is useful when your user just logged out. You’ve removed the\n   * user session, and you now want to make sure that any references to data you\n   * might have fetched while the user session was active is gone.\n   *\n   * It is important to remember that `resetStore()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   */\n  ApolloClient.prototype.resetStore = function () {\n    var _this = this;\n    return Promise.resolve().then(function () {\n      return _this.queryManager.clearStore({\n        discardWatches: false\n      });\n    }).then(function () {\n      return Promise.all(_this.resetStoreCallbacks.map(function (fn) {\n        return fn();\n      }));\n    }).then(function () {\n      return _this.reFetchObservableQueries();\n    });\n  };\n  /**\n   * Remove all data from the store. Unlike `resetStore`, `clearStore` will\n   * not refetch any active queries.\n   */\n  ApolloClient.prototype.clearStore = function () {\n    var _this = this;\n    return Promise.resolve().then(function () {\n      return _this.queryManager.clearStore({\n        discardWatches: true\n      });\n    }).then(function () {\n      return Promise.all(_this.clearStoreCallbacks.map(function (fn) {\n        return fn();\n      }));\n    });\n  };\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * reset. `onResetStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  ApolloClient.prototype.onResetStore = function (cb) {\n    var _this = this;\n    this.resetStoreCallbacks.push(cb);\n    return function () {\n      _this.resetStoreCallbacks = _this.resetStoreCallbacks.filter(function (c) {\n        return c !== cb;\n      });\n    };\n  };\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * cleared. `onClearStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  ApolloClient.prototype.onClearStore = function (cb) {\n    var _this = this;\n    this.clearStoreCallbacks.push(cb);\n    return function () {\n      _this.clearStoreCallbacks = _this.clearStoreCallbacks.filter(function (c) {\n        return c !== cb;\n      });\n    };\n  };\n  /**\n   * Refetches all of your active queries.\n   *\n   * `reFetchObservableQueries()` is useful if you want to bring the client back to proper state in case of a network outage\n   *\n   * It is important to remember that `reFetchObservableQueries()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   * Takes optional parameter `includeStandby` which will include queries in standby-mode when refetching.\n   */\n  ApolloClient.prototype.reFetchObservableQueries = function (includeStandby) {\n    return this.queryManager.reFetchObservableQueries(includeStandby);\n  };\n  /**\n   * Refetches specified active queries. Similar to \"reFetchObservableQueries()\" but with a specific list of queries.\n   *\n   * `refetchQueries()` is useful for use cases to imperatively refresh a selection of queries.\n   *\n   * It is important to remember that `refetchQueries()` *will* refetch specified active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   */\n  ApolloClient.prototype.refetchQueries = function (options) {\n    var map = this.queryManager.refetchQueries(options);\n    var queries = [];\n    var results = [];\n    map.forEach(function (result, obsQuery) {\n      queries.push(obsQuery);\n      results.push(result);\n    });\n    var result = Promise.all(results);\n    // In case you need the raw results immediately, without awaiting\n    // Promise.all(results):\n    result.queries = queries;\n    result.results = results;\n    // If you decide to ignore the result Promise because you're using\n    // result.queries and result.results instead, you shouldn't have to worry\n    // about preventing uncaught rejections for the Promise.all result.\n    result.catch(function (error) {\n      globalThis.__DEV__ !== false && invariant.debug(20, error);\n    });\n    return result;\n  };\n  /**\n   * Get all currently active `ObservableQuery` objects, in a `Map` keyed by\n   * query ID strings.\n   *\n   * An \"active\" query is one that has observers and a `fetchPolicy` other than\n   * \"standby\" or \"cache-only\".\n   *\n   * You can include all `ObservableQuery` objects (including the inactive ones)\n   * by passing \"all\" instead of \"active\", or you can include just a subset of\n   * active queries by passing an array of query names or DocumentNode objects.\n   */\n  ApolloClient.prototype.getObservableQueries = function (include) {\n    if (include === void 0) {\n      include = \"active\";\n    }\n    return this.queryManager.getObservableQueries(include);\n  };\n  /**\n   * Exposes the cache's complete state, in a serializable format for later restoration.\n   */\n  ApolloClient.prototype.extract = function (optimistic) {\n    return this.cache.extract(optimistic);\n  };\n  /**\n   * Replaces existing state in the cache (if any) with the values expressed by\n   * `serializedState`.\n   *\n   * Called when hydrating a cache (server side rendering, or offline storage),\n   * and also (potentially) during hot reloads.\n   */\n  ApolloClient.prototype.restore = function (serializedState) {\n    return this.cache.restore(serializedState);\n  };\n  /**\n   * Add additional local resolvers.\n   *\n   * @deprecated `addResolvers` will been removed in Apollo Client 4.0. It is\n   * safe to continue using this method in Apollo Client 3.x.\n   *\n   * **Recommended now**\n   *\n   * No action needed\n   *\n   * **When upgrading**\n   *\n   * Use `client.localState.addResolvers(resolvers)`. Alternatively, store\n   * the `LocalState` instance in a separate variable and call `addResolvers` on\n   * that.\n   */\n  ApolloClient.prototype.addResolvers = function (resolvers) {\n    this.localState.addResolvers(resolvers);\n  };\n  /**\n   * Set (override existing) local resolvers.\n   *\n   * @deprecated `setResolvers` will been removed in Apollo Client 4.0. It is\n   * safe to continue using this method in Apollo Client 3.x.\n   *\n   * **Recommended now**\n   *\n   * If possible, stop using the `setResolvers` method.\n   *\n   * **When upgrading**\n   *\n   * Remove the use of `setResolvers`.\n   */\n  ApolloClient.prototype.setResolvers = function (resolvers) {\n    this.localState.setResolvers(resolvers);\n  };\n  /**\n   * Get all registered local resolvers.\n   *\n   * @deprecated `getResolvers` will be removed in Apollo Client 4.0. It is\n   * safe to continue using this method in Apollo Client 3.x.\n   *\n   * **Recommended now**\n   *\n   * If possible, stop using the `getResolvers` method.\n   *\n   * **When upgrading**\n   *\n   * Remove the use of `getResolvers`.\n   */\n  ApolloClient.prototype.getResolvers = function () {\n    return this.localState.getResolvers();\n  };\n  /**\n   * Set a custom local state fragment matcher.\n   *\n   * @deprecated Custom fragment matchers will no longer be supported in Apollo\n   * Client 4.0 and has been replaced by `cache.fragmentMatches`. It is safe to\n   * continue using `setLocalStateFragmentMatcher` in Apollo Client 3.x.\n   *\n   * **Recommended now**\n   *\n   * No action needed\n   *\n   * **When upgrading**\n   *\n   * Leverage `possibleTypes` with `InMemoryCache` to ensure fragments match\n   * correctly. Ensure `possibleTypes` include local types if needed. If working\n   * with a 3rd party cache implementation, ensure the 3rd party cache implements\n   * the `cache.fragmentMatches` method. This function should no longer be used.\n   */\n  ApolloClient.prototype.setLocalStateFragmentMatcher = function (fragmentMatcher) {\n    this.localState.setFragmentMatcher(fragmentMatcher);\n  };\n  /**\n   * Define a new ApolloLink (or link chain) that Apollo Client will use.\n   */\n  ApolloClient.prototype.setLink = function (newLink) {\n    this.link = this.queryManager.link = newLink;\n  };\n  Object.defineProperty(ApolloClient.prototype, \"defaultContext\", {\n    get: function () {\n      return this.queryManager.defaultContext;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return ApolloClient;\n}();\nexport { ApolloClient };\nif (globalThis.__DEV__ !== false) {\n  ApolloClient.prototype.getMemoryInternals = getApolloClientMemoryInternals;\n}","map":{"version":3,"names":["invariant","newInvariantError","ApolloLink","execute","version","HttpLink","QueryManager","LocalState","hasSuggestedDevtools","mergeOptions","getApolloClientMemoryInternals","warnRemovedOption","ApolloClient","options","_this","resetStoreCallbacks","clearStoreCallbacks","cache","uri","credentials","headers","documentTransform","_d","ssrMode","_e","ssrForceFetchDelay","connectToDevTools","_f","queryDeduplication","defaultOptions","defaultContext","_g","assumeImmutableResults","resolvers","typeDefs","fragmentMatcher","clientAwareness","clientAwarenessName","name","clientAwarenessVersion","devtools","dataMasking","globalThis","__DEV__","link","warn","empty","disableNetworkFetches","Object","create","devtoolsConfig","__assign","enabled","_a","undefined","setTimeout","watchQuery","bind","query","mutate","watchFragment","resetStore","reFetchObservableQueries","localState","client","queryManager","_b","_c","onBroadcast","devToolsHookCb","action","state","queries","getQueryStore","mutations","mutationStore","extract","prototype","set","value","configurable","window","windowWithDevTools","devtoolsSymbol","Symbol","for","push","__APOLLO_CLIENT__","document","top","self","test","location","protocol","__APOLLO_DEVTOOLS_GLOBAL_HOOK__","nav","navigator","ua","userAgent","url","indexOf","log","defineProperty","stop","fetchPolicy","subscribe","startGraphQLSubscription","map","result","data","maskOperation","id","writeQuery","ref","__actionHookForDevTools","cb","__requestRaw","payload","clearStore","discardWatches","then","Promise","all","fn","onResetStore","filter","c","onClearStore","forEach","obsQuery","results","catch","error","debug","optimistic","setLink","newLink","get","enumerable","getMemoryInternals"],"sources":["/Users/lililyons/WebstormProjects/github-scanner/github-scanner-client/node_modules/@apollo/src/core/ApolloClient.ts"],"sourcesContent":["import { invariant, newInvariantError } from \"../utilities/globals/index.js\";\n\nimport type { DocumentNode, FormattedExecutionResult } from \"graphql\";\n\nimport type { GraphQLRequest } from \"../link/core/index.js\";\nimport { ApolloLink, execute } from \"../link/core/index.js\";\nimport type { ApolloCache, DataProxy, Reference } from \"../cache/index.js\";\nimport type { DocumentTransform } from \"../utilities/index.js\";\nimport type { Observable } from \"../utilities/index.js\";\nimport { version } from \"../version.js\";\nimport type { UriFunction } from \"../link/http/index.js\";\nimport { HttpLink } from \"../link/http/index.js\";\n\nimport { QueryManager } from \"./QueryManager.js\";\nimport type { ObservableQuery } from \"./ObservableQuery.js\";\n\nimport type {\n  DefaultContext,\n  OperationVariables,\n  Resolvers,\n  RefetchQueriesOptions,\n  RefetchQueriesResult,\n  InternalRefetchQueriesResult,\n  RefetchQueriesInclude,\n  InteropApolloQueryResult,\n  InteropMutateResult,\n  InteropSubscribeResult,\n} from \"./types.js\";\n\nimport type {\n  QueryOptions,\n  WatchQueryOptions,\n  MutationOptions,\n  SubscriptionOptions,\n  WatchQueryFetchPolicy,\n} from \"./watchQueryOptions.js\";\n\nimport type { FragmentMatcher } from \"./LocalState.js\";\nimport { LocalState } from \"./LocalState.js\";\n\nexport interface DefaultOptions {\n  watchQuery?: Partial<WatchQueryOptions<any, any>>;\n  query?: Partial<QueryOptions<any, any>>;\n  mutate?: Partial<MutationOptions<any, any, any>>;\n}\n\nexport interface DevtoolsOptions {\n  /**\n   * If `true`, the [Apollo Client Devtools](https://www.apollographql.com/docs/react/development-testing/developer-tooling/#apollo-client-devtools) browser extension can connect to this `ApolloClient` instance.\n   *\n   * The default value is `false` in production and `true` in development if there is a `window` object.\n   */\n  enabled?: boolean;\n\n  /**\n   * Optional name for this `ApolloClient` instance in the devtools. This is\n   * useful when you instantiate multiple clients and want to be able to\n   * identify them by name.\n   */\n  name?: string;\n}\n\nlet hasSuggestedDevtools = false;\n\nexport interface ApolloClientOptions<TCacheShape> {\n  /**\n   * The URI of the GraphQL endpoint that Apollo Client will communicate with.\n   *\n   * One of `uri` or `link` is **required**. If you provide both, `link` takes precedence.\n   *\n   * @deprecated `uri` will be removed in Apollo Client 4.0.\n   *\n   * **Recommended now**\n   *\n   * Instantiate an instance of `HttpClient` and pass `uri` as an option.\n   *\n   * ```js\n   * import { HttpLink } from \"@apollo/client\";\n   *\n   * new ApolloClient({\n   *   link: new HttpLink({ uri })\n   * });\n   * ```\n   */\n  uri?: string | UriFunction;\n\n  /**\n   * @deprecated `credentials` will be removed in Apollo Client 4.0.\n   *\n   * **Recommended now**\n   *\n   * Instantiate an instance of `HttpClient` and pass `credentials` as an option.\n   *\n   * ```js\n   * import { HttpLink } from \"@apollo/client\";\n   *\n   * new ApolloClient({\n   *   link: new HttpLink({ credentials })\n   * });\n   * ```\n   */\n  credentials?: string;\n  /**\n   * An object representing headers to include in every HTTP request, such as `{Authorization: 'Bearer 1234'}`\n   *\n   * This value will be ignored when using the `link` option.\n   *\n   * @deprecated `headers` will be removed in Apollo Client 4.0.\n   *\n   * **Recommended now**\n   *\n   * Instantiate an instance of `HttpClient` and pass `headers` as an option.\n   *\n   * ```js\n   * import { HttpLink } from \"@apollo/client\";\n   *\n   * new ApolloClient({\n   *   link: new HttpLink({ headers })\n   * });\n   * ```\n   */\n  headers?: Record<string, string>;\n  /**\n   * You can provide an `ApolloLink` instance to serve as Apollo Client's network layer. For more information, see [Advanced HTTP networking](https://www.apollographql.com/docs/react/networking/advanced-http-networking/).\n   *\n   * One of `uri` or `link` is **required**. If you provide both, `link` takes precedence.\n   */\n  link?: ApolloLink;\n  /**\n   * The cache that Apollo Client should use to store query results locally. The recommended cache is `InMemoryCache`, which is provided by the `@apollo/client` package.\n   *\n   * For more information, see [Configuring the cache](https://www.apollographql.com/docs/react/caching/cache-configuration/).\n   */\n  cache: ApolloCache<TCacheShape>;\n  /**\n   * The time interval (in milliseconds) before Apollo Client force-fetches queries after a server-side render.\n   *\n   * @defaultValue `0` (no delay)\n   */\n  ssrForceFetchDelay?: number;\n  /**\n   * When using Apollo Client for [server-side rendering](https://www.apollographql.com/docs/react/performance/server-side-rendering/), set this to `true` so that the [`getDataFromTree` function](../react/ssr/#getdatafromtree) can work effectively.\n   *\n   * @defaultValue `false`\n   */\n  ssrMode?: boolean;\n  /**\n   * If `true`, the [Apollo Client Devtools](https://www.apollographql.com/docs/react/development-testing/developer-tooling/#apollo-client-devtools) browser extension can connect to Apollo Client.\n   *\n   * The default value is `false` in production and `true` in development (if there is a `window` object).\n   *\n   * @deprecated `connectToDevTools` will be removed in Apollo Client 4.0.\n   *\n   * **Recommended now**\n   *\n   * Use the `devtools.enabled` option instead.\n   *\n   * ```ts\n   * new ApolloClient({\n   *   devtools: { enabled: true }\n   * });\n   * ```\n   */\n  connectToDevTools?: boolean;\n  /**\n   * If `false`, Apollo Client sends every created query to the server, even if a _completely_ identical query (identical in terms of query string, variable values, and operationName) is already in flight.\n   *\n   * @defaultValue `true`\n   */\n  queryDeduplication?: boolean;\n  /**\n   * Provide this object to set application-wide default values for options you can provide to the `watchQuery`, `query`, and `mutate` functions. See below for an example object.\n   *\n   * See this [example object](https://www.apollographql.com/docs/react/api/core/ApolloClient#example-defaultoptions-object).\n   */\n  defaultOptions?: DefaultOptions;\n  defaultContext?: Partial<DefaultContext>;\n  /**\n   * If `true`, Apollo Client will assume results read from the cache are never mutated by application code, which enables substantial performance optimizations.\n   *\n   * @defaultValue `false`\n   */\n  assumeImmutableResults?: boolean;\n\n  /**\n   * @deprecated `resolvers` has been moved in Apollo Client 4.0. This option is\n   * safe to use in Apollo Client 3.x.\n   *\n   * **Recommended now**\n   *\n   * No action needed\n   *\n   * **When upgrading**\n   *\n   * `resolvers` will need to be passed as the `resolvers` option to an instance\n   * of `LocalState`. That `LocalState` instance should be provided as the\n   * `localState` option to the `ApolloClient` constructor.\n   */\n  resolvers?: Resolvers | Resolvers[];\n\n  /**\n   * @deprecated `typeDefs` will be removed in Apollo Client 4.0. It is safe to\n   * stop using this option in Apollo Client 3.x.\n   */\n  typeDefs?: string | string[] | DocumentNode | DocumentNode[];\n\n  /**\n   * @deprecated Custom fragment matchers will no longer be supported in Apollo\n   * Client 4.0 and has been replaced by `cache.fragmentMatches`. It is safe to\n   * continue using this in Apollo Client 3.x.\n   *\n   * **Recommended now**\n   *\n   * No action needed\n   *\n   * **When upgrading**\n   *\n   * Leverage `possibleTypes` with `InMemoryCache` to ensure fragments match\n   * correctly. Ensure `possibleTypes` include local types if needed. This\n   * option should then be removed. If working with a 3rd party cache\n   * implementation, ensure the 3rd party cache implements the\n   * `cache.fragmentMatches` method.\n   */\n  fragmentMatcher?: FragmentMatcher;\n  /**\n   * A custom name (e.g., `iOS`) that identifies this particular client among your set of clients. Apollo Server and Apollo Studio use this property as part of the [client awareness](https://www.apollographql.com/docs/apollo-server/monitoring/metrics#identifying-distinct-clients) feature.\n   *\n   * @deprecated `name` has been moved to `clientAwareness.name` in Apollo Client 4.0.\n   *\n   * **Recommended now**\n   *\n   * Use `clientAwareness.name` to set the client awareness name.\n   *\n   * ```ts\n   * new ApolloClient({ clientAwareness: { name } });\n   * ```\n   */\n  name?: string;\n  /**\n   * A custom version that identifies the current version of this particular client (e.g., `1.2`). Apollo Server and Apollo Studio use this property as part of the [client awareness](https://www.apollographql.com/docs/apollo-server/monitoring/metrics#identifying-distinct-clients) feature.\n   *\n   * This is **not** the version of Apollo Client that you are using, but rather any version string that helps you differentiate between versions of your client.\n   *\n   * @deprecated `name` has been moved to `clientAwareness.version` in Apollo Client 4.0.\n   *\n   * **Recommended now**\n   *\n   * Use `clientAwareness.version` to set the client awareness version.\n   *\n   * ```ts\n   * new ApolloClient({ clientAwareness: { version } });\n   * ```\n   */\n  version?: string;\n\n  clientAwareness?: {\n    /**\n     * A custom name (e.g., `iOS`) that identifies this particular client among your set of clients. Apollo Server and Apollo Studio use this property as part of the [client awareness](https://www.apollographql.com/docs/apollo-server/monitoring/metrics#identifying-distinct-clients) feature.\n     */\n    name?: string;\n    /**\n     * A custom version that identifies the current version of this particular client (e.g., `1.2`). Apollo Server and Apollo Studio use this property as part of the [client awareness](https://www.apollographql.com/docs/apollo-server/monitoring/metrics#identifying-distinct-clients) feature.\n     *\n     * This is **not** the version of Apollo Client that you are using, but rather any version string that helps you differentiate between versions of your client.\n     */\n    version?: string;\n  };\n\n  documentTransform?: DocumentTransform;\n\n  /**\n   * Configuration used by the [Apollo Client Devtools extension](https://www.apollographql.com/docs/react/development-testing/developer-tooling/#apollo-client-devtools) for this client.\n   *\n   * @since 3.11.0\n   */\n  devtools?: DevtoolsOptions;\n\n  /**\n   * Determines if data masking is enabled for the client.\n   *\n   * @defaultValue false\n   */\n  dataMasking?: boolean;\n}\n\n// Though mergeOptions now resides in @apollo/client/utilities, it was\n// previously declared and exported from this module, and then reexported from\n// @apollo/client/core. Since we need to preserve that API anyway, the easiest\n// solution is to reexport mergeOptions where it was previously declared (here).\nimport { mergeOptions } from \"../utilities/index.js\";\nimport { getApolloClientMemoryInternals } from \"../utilities/caching/getMemoryInternals.js\";\nimport type {\n  WatchFragmentOptions,\n  WatchFragmentResult,\n} from \"../cache/core/cache.js\";\nimport type { MaybeMasked, Unmasked } from \"../masking/index.js\";\nimport { warnRemovedOption } from \"../utilities/deprecation/index.js\";\nexport { mergeOptions };\n\n/**\n * This is the primary Apollo Client class. It is used to send GraphQL documents (i.e. queries\n * and mutations) to a GraphQL spec-compliant server over an `ApolloLink` instance,\n * receive results from the server and cache the results in a store. It also delivers updates\n * to GraphQL queries through `Observable` instances.\n */\nexport class ApolloClient<TCacheShape = any> implements DataProxy {\n  public link: ApolloLink;\n  public cache: ApolloCache<TCacheShape>;\n\n  /**\n   * @deprecated `disableNetworkFetches` has been renamed to `prioritizeCacheValues`\n   * in Apollo Client 4.0.\n   *\n   * **Recommended now**\n   *\n   * Access `client.prioritizeCacheValues` instead.\n   */\n  public disableNetworkFetches: boolean;\n  public version: string;\n  public queryDeduplication: boolean;\n  public defaultOptions: DefaultOptions;\n  public readonly typeDefs: ApolloClientOptions<TCacheShape>[\"typeDefs\"];\n  public readonly devtoolsConfig: DevtoolsOptions;\n\n  private queryManager: QueryManager<TCacheShape>;\n  private devToolsHookCb?: Function;\n  private resetStoreCallbacks: Array<() => Promise<any>> = [];\n  private clearStoreCallbacks: Array<() => Promise<any>> = [];\n  public localState: LocalState<TCacheShape>;\n\n  /**\n   * Whether to prioritize cache values over network results when `query` or `watchQuery` is called.\n   * This will essentially turn a `\"network-only\"` or `\"cache-and-network\"` fetchPolicy into a `\"cache-first\"` fetchPolicy,\n   * but without influencing the `fetchPolicy` of the created `ObservableQuery` long-term.\n   *\n   * This can e.g. be used to prioritize the cache during the first render after SSR.\n   */\n  public get prioritizeCacheValues() {\n    return this.disableNetworkFetches;\n  }\n\n  public set prioritizeCacheValues(value: boolean) {\n    this.disableNetworkFetches = value;\n  }\n\n  /**\n   * Constructs an instance of `ApolloClient`.\n   *\n   * @example\n   * ```js\n   * import { ApolloClient, InMemoryCache } from '@apollo/client';\n   *\n   * const cache = new InMemoryCache();\n   *\n   * const client = new ApolloClient({\n   *   // Provide required constructor fields\n   *   cache: cache,\n   *   uri: 'http://localhost:4000/',\n   *\n   *   // Provide some optional constructor fields\n   *   name: 'react-web-client',\n   *   version: '1.3',\n   *   queryDeduplication: false,\n   *   defaultOptions: {\n   *     watchQuery: {\n   *       fetchPolicy: 'cache-and-network',\n   *     },\n   *   },\n   * });\n   * ```\n   */\n  constructor(options: ApolloClientOptions<TCacheShape>) {\n    if (!options.cache) {\n      throw newInvariantError(\n        \"To initialize Apollo Client, you must specify a 'cache' property \" +\n          \"in the options object. \\n\" +\n          \"For more information, please visit: https://go.apollo.dev/c/docs\"\n      );\n    }\n\n    const {\n      uri,\n      credentials,\n      headers,\n      cache,\n      documentTransform,\n      ssrMode = false,\n      ssrForceFetchDelay = 0,\n      // Expose the client instance as window.__APOLLO_CLIENT__ and call\n      // onBroadcast in queryManager.broadcastQueries to enable browser\n      // devtools, but disable them by default in production.\n      connectToDevTools,\n      queryDeduplication = true,\n      defaultOptions,\n      defaultContext,\n      assumeImmutableResults = cache.assumeImmutableResults,\n      resolvers,\n      typeDefs,\n      fragmentMatcher,\n      clientAwareness,\n      name: clientAwarenessName,\n      version: clientAwarenessVersion,\n      devtools,\n      dataMasking,\n    } = options;\n\n    if (__DEV__) {\n      warnRemovedOption(\n        options,\n        \"connectToDevTools\",\n        \"ApolloClient\",\n        \"Please use `devtools.enabled` instead.\"\n      );\n      warnRemovedOption(\n        options,\n        \"uri\",\n        \"ApolloClient\",\n        \"Please initialize an instance of `HttpLink` with `uri` instead.\"\n      );\n      warnRemovedOption(\n        options,\n        \"credentials\",\n        \"ApolloClient\",\n        \"Please initialize an instance of `HttpLink` with `credentials` instead.\"\n      );\n      warnRemovedOption(\n        options,\n        \"headers\",\n        \"ApolloClient\",\n        \"Please initialize an instance of `HttpLink` with `headers` instead.\"\n      );\n      warnRemovedOption(\n        options,\n        \"name\",\n        \"ApolloClient\",\n        \"Please use the `clientAwareness.name` option instead.\"\n      );\n      warnRemovedOption(\n        options,\n        \"version\",\n        \"ApolloClient\",\n        \"Please use the `clientAwareness.version` option instead.\"\n      );\n      warnRemovedOption(options, \"typeDefs\", \"ApolloClient\");\n\n      if (!options.link) {\n        invariant.warn(\n          \"[ApolloClient]: Apollo Client 4.0 will require a `link` option and will not create a default link when not provided. Please provide a `link` option.\"\n        );\n      }\n    }\n\n    let { link } = options;\n\n    if (!link) {\n      link =\n        uri ? new HttpLink({ uri, credentials, headers }) : ApolloLink.empty();\n    }\n\n    this.link = link;\n    this.cache = cache;\n    this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;\n    this.queryDeduplication = queryDeduplication;\n    this.defaultOptions = defaultOptions || Object.create(null);\n    this.typeDefs = typeDefs;\n    this.devtoolsConfig = {\n      ...devtools,\n      enabled: devtools?.enabled ?? connectToDevTools,\n    };\n\n    if (this.devtoolsConfig.enabled === undefined) {\n      this.devtoolsConfig.enabled = __DEV__;\n    }\n\n    if (ssrForceFetchDelay) {\n      setTimeout(\n        () => (this.disableNetworkFetches = false),\n        ssrForceFetchDelay\n      );\n    }\n\n    this.watchQuery = this.watchQuery.bind(this);\n    this.query = this.query.bind(this);\n    this.mutate = this.mutate.bind(this);\n    this.watchFragment = this.watchFragment.bind(this);\n    this.resetStore = this.resetStore.bind(this);\n    this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);\n\n    this.version = version;\n\n    this.localState = new LocalState({\n      cache,\n      client: this,\n      resolvers,\n      fragmentMatcher,\n    });\n\n    this.queryManager = new QueryManager({\n      cache: this.cache,\n      link: this.link,\n      defaultOptions: this.defaultOptions,\n      defaultContext,\n      documentTransform,\n      queryDeduplication,\n      ssrMode,\n      dataMasking: !!dataMasking,\n      clientAwareness: {\n        name: clientAwareness?.name ?? clientAwarenessName!,\n        version: clientAwareness?.version ?? clientAwarenessVersion!,\n      },\n      localState: this.localState,\n      assumeImmutableResults,\n      onBroadcast:\n        this.devtoolsConfig.enabled ?\n          () => {\n            if (this.devToolsHookCb) {\n              this.devToolsHookCb({\n                action: {},\n                state: {\n                  queries: this.queryManager.getQueryStore(),\n                  mutations: this.queryManager.mutationStore || {},\n                },\n                dataWithOptimisticResults: this.cache.extract(true),\n              });\n            }\n          }\n        : void 0,\n    });\n\n    if (this.devtoolsConfig.enabled) this.connectToDevTools();\n  }\n\n  private connectToDevTools() {\n    if (typeof window === \"undefined\") {\n      return;\n    }\n\n    type DevToolsConnector = {\n      push(client: ApolloClient<any>): void;\n    };\n    const windowWithDevTools = window as Window & {\n      [devtoolsSymbol]?: DevToolsConnector;\n      __APOLLO_CLIENT__?: ApolloClient<any>;\n    };\n    const devtoolsSymbol = Symbol.for(\"apollo.devtools\");\n    (windowWithDevTools[devtoolsSymbol] =\n      windowWithDevTools[devtoolsSymbol] || ([] as DevToolsConnector)).push(\n      this\n    );\n    windowWithDevTools.__APOLLO_CLIENT__ = this;\n\n    /**\n     * Suggest installing the devtools for developers who don't have them\n     */\n    if (!hasSuggestedDevtools && __DEV__) {\n      hasSuggestedDevtools = true;\n      if (\n        window.document &&\n        window.top === window.self &&\n        /^(https?|file):$/.test(window.location.protocol)\n      ) {\n        setTimeout(() => {\n          if (!(window as any).__APOLLO_DEVTOOLS_GLOBAL_HOOK__) {\n            const nav = window.navigator;\n            const ua = nav && nav.userAgent;\n            let url: string | undefined;\n            if (typeof ua === \"string\") {\n              if (ua.indexOf(\"Chrome/\") > -1) {\n                url =\n                  \"https://chrome.google.com/webstore/detail/\" +\n                  \"apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm\";\n              } else if (ua.indexOf(\"Firefox/\") > -1) {\n                url =\n                  \"https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/\";\n              }\n            }\n            if (url) {\n              invariant.log(\n                \"Download the Apollo DevTools for a better development \" +\n                  \"experience: %s\",\n                url\n              );\n            }\n          }\n        }, 10000);\n      }\n    }\n  }\n\n  /**\n   * The `DocumentTransform` used to modify GraphQL documents before a request\n   * is made. If a custom `DocumentTransform` is not provided, this will be the\n   * default document transform.\n   */\n  get documentTransform() {\n    return this.queryManager.documentTransform;\n  }\n\n  /**\n   * Call this method to terminate any active client processes, making it safe\n   * to dispose of this `ApolloClient` instance.\n   */\n  public stop() {\n    this.queryManager.stop();\n  }\n\n  /**\n   * This watches the cache store of the query according to the options specified and\n   * returns an `ObservableQuery`. We can subscribe to this `ObservableQuery` and\n   * receive updated results through an observer when the cache store changes.\n   *\n   * Note that this method is not an implementation of GraphQL subscriptions. Rather,\n   * it uses Apollo's store in order to reactively deliver updates to your query results.\n   *\n   * For example, suppose you call watchQuery on a GraphQL query that fetches a person's\n   * first and last name and this person has a particular object identifier, provided by\n   * dataIdFromObject. Later, a different query fetches that same person's\n   * first and last name and the first name has now changed. Then, any observers associated\n   * with the results of the first query will be updated with a new result object.\n   *\n   * Note that if the cache does not change, the subscriber will *not* be notified.\n   *\n   * See [here](https://medium.com/apollo-stack/the-concepts-of-graphql-bc68bd819be3#.3mb0cbcmc) for\n   * a description of store reactivity.\n   */\n  public watchQuery<\n    T = any,\n    TVariables extends OperationVariables = OperationVariables,\n  >(options: WatchQueryOptions<TVariables, T>): ObservableQuery<T, TVariables> {\n    if (this.defaultOptions.watchQuery) {\n      options = mergeOptions(this.defaultOptions.watchQuery, options);\n    }\n\n    // XXX Overwriting options is probably not the best way to do this long term...\n    if (\n      this.disableNetworkFetches &&\n      (options.fetchPolicy === \"network-only\" ||\n        options.fetchPolicy === \"cache-and-network\")\n    ) {\n      options = { ...options, fetchPolicy: \"cache-first\" };\n    }\n\n    if (__DEV__) {\n      warnRemovedOption(options, \"canonizeResults\", \"client.watchQuery\");\n      warnRemovedOption(options, \"partialRefetch\", \"client.watchQuery\");\n    }\n\n    return this.queryManager.watchQuery<T, TVariables>(options);\n  }\n\n  /**\n   * This resolves a single query according to the options specified and\n   * returns a `Promise` which is either resolved with the resulting data\n   * or rejected with an error.\n   *\n   * @param options - An object of type `QueryOptions` that allows us to\n   * describe how this query should be treated e.g. whether it should hit the\n   * server at all or just resolve from the cache, etc.\n   */\n  public query<\n    T = any,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: QueryOptions<TVariables, T>\n  ): Promise<InteropApolloQueryResult<MaybeMasked<T>>> {\n    if (this.defaultOptions.query) {\n      options = mergeOptions(this.defaultOptions.query, options);\n    }\n\n    invariant(\n      (options.fetchPolicy as WatchQueryFetchPolicy) !== \"cache-and-network\",\n      \"The cache-and-network fetchPolicy does not work with client.query, because \" +\n        \"client.query can only return a single result. Please use client.watchQuery \" +\n        \"to receive multiple results from the cache and the network, or consider \" +\n        \"using a different fetchPolicy, such as cache-first or network-only.\"\n    );\n\n    if (this.disableNetworkFetches && options.fetchPolicy === \"network-only\") {\n      options = { ...options, fetchPolicy: \"cache-first\" };\n    }\n\n    if (__DEV__) {\n      warnRemovedOption(options, \"canonizeResults\", \"client.query\");\n      warnRemovedOption(\n        options,\n        \"notifyOnNetworkStatusChange\",\n        \"client.query\",\n        \"This option does not affect `client.query` and can be safely removed.\"\n      );\n\n      if (options.fetchPolicy === \"standby\") {\n        invariant.warn(\n          \"[client.query]: Apollo Client 4.0 will no longer support the `standby` fetch policy with `client.query`. Please use a different fetch policy.\"\n        );\n      }\n    }\n\n    return this.queryManager.query<T, TVariables>(options);\n  }\n\n  /**\n   * This resolves a single mutation according to the options specified and returns a\n   * Promise which is either resolved with the resulting data or rejected with an\n   * error. In some cases both `data` and `errors` might be undefined, for example\n   * when `errorPolicy` is set to `'ignore'`.\n   *\n   * It takes options as an object with the following keys and values:\n   */\n  public mutate<\n    TData = any,\n    TVariables extends OperationVariables = OperationVariables,\n    TContext extends Record<string, any> = DefaultContext,\n    TCache extends ApolloCache<any> = ApolloCache<any>,\n  >(\n    options: MutationOptions<TData, TVariables, TContext>\n  ): Promise<InteropMutateResult<MaybeMasked<TData>>> {\n    if (this.defaultOptions.mutate) {\n      options = mergeOptions(this.defaultOptions.mutate, options);\n    }\n    return this.queryManager.mutate<TData, TVariables, TContext, TCache>(\n      options\n    );\n  }\n\n  /**\n   * This subscribes to a graphql subscription according to the options specified and returns an\n   * `Observable` which either emits received data or an error.\n   */\n  public subscribe<\n    T = any,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    options: SubscriptionOptions<TVariables, T>\n  ): Observable<InteropSubscribeResult<MaybeMasked<T>>> {\n    const id = this.queryManager.generateQueryId();\n\n    return this.queryManager\n      .startGraphQLSubscription<T>(options)\n      .map((result) => ({\n        ...result,\n        data: this.queryManager.maskOperation({\n          document: options.query,\n          data: result.data,\n          fetchPolicy: options.fetchPolicy,\n          id,\n        }),\n      }));\n  }\n\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL query without making a network request. This method will start at\n   * the root query. To start at a specific id returned by `dataIdFromObject`\n   * use `readFragment`.\n   *\n   * @param optimistic - Set to `true` to allow `readQuery` to return\n   * optimistic results. Is `false` by default.\n   */\n  public readQuery<T = any, TVariables = OperationVariables>(\n    options: DataProxy.Query<TVariables, T>,\n    optimistic: boolean = false\n  ): Unmasked<T> | null {\n    return this.cache.readQuery<T, TVariables>(options, optimistic);\n  }\n\n  /**\n   * Watches the cache store of the fragment according to the options specified\n   * and returns an `Observable`. We can subscribe to this\n   * `Observable` and receive updated results through an\n   * observer when the cache store changes.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are reading. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   *\n   * @since 3.10.0\n   * @param options - An object of type `WatchFragmentOptions` that allows\n   * the cache to identify the fragment and optionally specify whether to react\n   * to optimistic updates.\n   */\n\n  public watchFragment<\n    TFragmentData = unknown,\n    TVariables = OperationVariables,\n  >(\n    options: WatchFragmentOptions<TFragmentData, TVariables>\n  ): Observable<WatchFragmentResult<TFragmentData>> {\n    return this.cache.watchFragment({\n      ...options,\n      [Symbol.for(\"apollo.dataMasking\")]: this.queryManager.dataMasking,\n    });\n  }\n\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL fragment without making a network request. This method will read a\n   * GraphQL fragment from any arbitrary id that is currently cached, unlike\n   * `readQuery` which will only read from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are reading. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   *\n   * @param optimistic - Set to `true` to allow `readFragment` to return\n   * optimistic results. Is `false` by default.\n   */\n  public readFragment<T = any, TVariables = OperationVariables>(\n    options: DataProxy.Fragment<TVariables, T>,\n    optimistic: boolean = false\n  ): Unmasked<T> | null {\n    return this.cache.readFragment<T, TVariables>(options, optimistic);\n  }\n\n  /**\n   * Writes some data in the shape of the provided GraphQL query directly to\n   * the store. This method will start at the root query. To start at a\n   * specific id returned by `dataIdFromObject` then use `writeFragment`.\n   */\n  public writeQuery<TData = any, TVariables = OperationVariables>(\n    options: DataProxy.WriteQueryOptions<TData, TVariables>\n  ): Reference | undefined {\n    const ref = this.cache.writeQuery<TData, TVariables>(options);\n\n    if (options.broadcast !== false) {\n      this.queryManager.broadcastQueries();\n    }\n\n    return ref;\n  }\n\n  /**\n   * Writes some data in the shape of the provided GraphQL fragment directly to\n   * the store. This method will write to a GraphQL fragment from any arbitrary\n   * id that is currently cached, unlike `writeQuery` which will only write\n   * from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are writing. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   */\n  public writeFragment<TData = any, TVariables = OperationVariables>(\n    options: DataProxy.WriteFragmentOptions<TData, TVariables>\n  ): Reference | undefined {\n    const ref = this.cache.writeFragment<TData, TVariables>(options);\n\n    if (options.broadcast !== false) {\n      this.queryManager.broadcastQueries();\n    }\n\n    return ref;\n  }\n\n  public __actionHookForDevTools(cb: () => any) {\n    this.devToolsHookCb = cb;\n  }\n\n  public __requestRaw(\n    payload: GraphQLRequest\n  ): Observable<FormattedExecutionResult> {\n    return execute(this.link, payload);\n  }\n\n  /**\n   * Resets your entire store by clearing out your cache and then re-executing\n   * all of your active queries. This makes it so that you may guarantee that\n   * there is no data left in your store from a time before you called this\n   * method.\n   *\n   * `resetStore()` is useful when your user just logged out. You’ve removed the\n   * user session, and you now want to make sure that any references to data you\n   * might have fetched while the user session was active is gone.\n   *\n   * It is important to remember that `resetStore()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   */\n  public resetStore(): Promise<InteropApolloQueryResult<any>[] | null> {\n    return Promise.resolve()\n      .then(() =>\n        this.queryManager.clearStore({\n          discardWatches: false,\n        })\n      )\n      .then(() => Promise.all(this.resetStoreCallbacks.map((fn) => fn())))\n      .then(() => this.reFetchObservableQueries());\n  }\n\n  /**\n   * Remove all data from the store. Unlike `resetStore`, `clearStore` will\n   * not refetch any active queries.\n   */\n  public clearStore(): Promise<any[]> {\n    return Promise.resolve()\n      .then(() =>\n        this.queryManager.clearStore({\n          discardWatches: true,\n        })\n      )\n      .then(() => Promise.all(this.clearStoreCallbacks.map((fn) => fn())));\n  }\n\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * reset. `onResetStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  public onResetStore(cb: () => Promise<any>): () => void {\n    this.resetStoreCallbacks.push(cb);\n    return () => {\n      this.resetStoreCallbacks = this.resetStoreCallbacks.filter(\n        (c) => c !== cb\n      );\n    };\n  }\n\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * cleared. `onClearStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  public onClearStore(cb: () => Promise<any>): () => void {\n    this.clearStoreCallbacks.push(cb);\n    return () => {\n      this.clearStoreCallbacks = this.clearStoreCallbacks.filter(\n        (c) => c !== cb\n      );\n    };\n  }\n\n  /**\n   * Refetches all of your active queries.\n   *\n   * `reFetchObservableQueries()` is useful if you want to bring the client back to proper state in case of a network outage\n   *\n   * It is important to remember that `reFetchObservableQueries()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   * Takes optional parameter `includeStandby` which will include queries in standby-mode when refetching.\n   */\n  public reFetchObservableQueries(\n    includeStandby?: boolean\n  ): Promise<InteropApolloQueryResult<any>[]> {\n    return this.queryManager.reFetchObservableQueries(includeStandby);\n  }\n\n  /**\n   * Refetches specified active queries. Similar to \"reFetchObservableQueries()\" but with a specific list of queries.\n   *\n   * `refetchQueries()` is useful for use cases to imperatively refresh a selection of queries.\n   *\n   * It is important to remember that `refetchQueries()` *will* refetch specified active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   */\n  public refetchQueries<\n    TCache extends ApolloCache<any> = ApolloCache<TCacheShape>,\n    TResult = Promise<InteropApolloQueryResult<any>>,\n  >(\n    options: RefetchQueriesOptions<TCache, TResult>\n  ): RefetchQueriesResult<TResult> {\n    const map = this.queryManager.refetchQueries(\n      options as RefetchQueriesOptions<ApolloCache<TCacheShape>, TResult>\n    );\n    const queries: ObservableQuery<any>[] = [];\n    const results: InternalRefetchQueriesResult<TResult>[] = [];\n\n    map.forEach((result, obsQuery) => {\n      queries.push(obsQuery);\n      results.push(result);\n    });\n\n    const result = Promise.all<TResult>(\n      results as TResult[]\n    ) as RefetchQueriesResult<TResult>;\n\n    // In case you need the raw results immediately, without awaiting\n    // Promise.all(results):\n    result.queries = queries;\n    result.results = results;\n\n    // If you decide to ignore the result Promise because you're using\n    // result.queries and result.results instead, you shouldn't have to worry\n    // about preventing uncaught rejections for the Promise.all result.\n    result.catch((error) => {\n      invariant.debug(\n        `In client.refetchQueries, Promise.all promise rejected with error %o`,\n        error\n      );\n    });\n\n    return result;\n  }\n\n  /**\n   * Get all currently active `ObservableQuery` objects, in a `Map` keyed by\n   * query ID strings.\n   *\n   * An \"active\" query is one that has observers and a `fetchPolicy` other than\n   * \"standby\" or \"cache-only\".\n   *\n   * You can include all `ObservableQuery` objects (including the inactive ones)\n   * by passing \"all\" instead of \"active\", or you can include just a subset of\n   * active queries by passing an array of query names or DocumentNode objects.\n   */\n  public getObservableQueries(\n    include: RefetchQueriesInclude = \"active\"\n  ): Map<string, ObservableQuery<any>> {\n    return this.queryManager.getObservableQueries(include);\n  }\n\n  /**\n   * Exposes the cache's complete state, in a serializable format for later restoration.\n   */\n  public extract(optimistic?: boolean): TCacheShape {\n    return this.cache.extract(optimistic);\n  }\n\n  /**\n   * Replaces existing state in the cache (if any) with the values expressed by\n   * `serializedState`.\n   *\n   * Called when hydrating a cache (server side rendering, or offline storage),\n   * and also (potentially) during hot reloads.\n   */\n  public restore(serializedState: TCacheShape): ApolloCache<TCacheShape> {\n    return this.cache.restore(serializedState);\n  }\n\n  /**\n   * Add additional local resolvers.\n   *\n   * @deprecated `addResolvers` will been removed in Apollo Client 4.0. It is\n   * safe to continue using this method in Apollo Client 3.x.\n   *\n   * **Recommended now**\n   *\n   * No action needed\n   *\n   * **When upgrading**\n   *\n   * Use `client.localState.addResolvers(resolvers)`. Alternatively, store\n   * the `LocalState` instance in a separate variable and call `addResolvers` on\n   * that.\n   */\n  public addResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.localState.addResolvers(resolvers);\n  }\n\n  /**\n   * Set (override existing) local resolvers.\n   *\n   * @deprecated `setResolvers` will been removed in Apollo Client 4.0. It is\n   * safe to continue using this method in Apollo Client 3.x.\n   *\n   * **Recommended now**\n   *\n   * If possible, stop using the `setResolvers` method.\n   *\n   * **When upgrading**\n   *\n   * Remove the use of `setResolvers`.\n   */\n  public setResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.localState.setResolvers(resolvers);\n  }\n\n  /**\n   * Get all registered local resolvers.\n   *\n   * @deprecated `getResolvers` will be removed in Apollo Client 4.0. It is\n   * safe to continue using this method in Apollo Client 3.x.\n   *\n   * **Recommended now**\n   *\n   * If possible, stop using the `getResolvers` method.\n   *\n   * **When upgrading**\n   *\n   * Remove the use of `getResolvers`.\n   */\n  public getResolvers() {\n    return this.localState.getResolvers();\n  }\n\n  /**\n   * Set a custom local state fragment matcher.\n   *\n   * @deprecated Custom fragment matchers will no longer be supported in Apollo\n   * Client 4.0 and has been replaced by `cache.fragmentMatches`. It is safe to\n   * continue using `setLocalStateFragmentMatcher` in Apollo Client 3.x.\n   *\n   * **Recommended now**\n   *\n   * No action needed\n   *\n   * **When upgrading**\n   *\n   * Leverage `possibleTypes` with `InMemoryCache` to ensure fragments match\n   * correctly. Ensure `possibleTypes` include local types if needed. If working\n   * with a 3rd party cache implementation, ensure the 3rd party cache implements\n   * the `cache.fragmentMatches` method. This function should no longer be used.\n   */\n  public setLocalStateFragmentMatcher(fragmentMatcher: FragmentMatcher) {\n    this.localState.setFragmentMatcher(fragmentMatcher);\n  }\n\n  /**\n   * Define a new ApolloLink (or link chain) that Apollo Client will use.\n   */\n  public setLink(newLink: ApolloLink) {\n    this.link = this.queryManager.link = newLink;\n  }\n\n  public get defaultContext() {\n    return this.queryManager.defaultContext;\n  }\n\n  /**\n   * @experimental\n   * This is not a stable API - it is used in development builds to expose\n   * information to the DevTools.\n   * Use at your own risk!\n   * For more details, see [Memory Management](https://www.apollographql.com/docs/react/caching/memory-management/#measuring-cache-usage)\n   *\n   * @example\n   * ```ts\n   * console.log(client.getMemoryInternals())\n   * ```\n   * Logs output in the following JSON format:\n   * @example\n   * ```json\n   *{\n   *  limits:     {\n   *    parser: 1000,\n   *    canonicalStringify: 1000,\n   *    print: 2000,\n   *    'documentTransform.cache': 2000,\n   *    'queryManager.getDocumentInfo': 2000,\n   *    'PersistedQueryLink.persistedQueryHashes': 2000,\n   *    'fragmentRegistry.transform': 2000,\n   *    'fragmentRegistry.lookup': 1000,\n   *    'fragmentRegistry.findFragmentSpreads': 4000,\n   *    'cache.fragmentQueryDocuments': 1000,\n   *    'removeTypenameFromVariables.getVariableDefinitions': 2000,\n   *    'inMemoryCache.maybeBroadcastWatch': 5000,\n   *    'inMemoryCache.executeSelectionSet': 10000,\n   *    'inMemoryCache.executeSubSelectedArray': 5000\n   *  },\n   *  sizes: {\n   *    parser: 26,\n   *    canonicalStringify: 4,\n   *    print: 14,\n   *    addTypenameDocumentTransform: [\n   *      {\n   *        cache: 14,\n   *      },\n   *    ],\n   *    queryManager: {\n   *      getDocumentInfo: 14,\n   *      documentTransforms: [\n   *        {\n   *          cache: 14,\n   *        },\n   *        {\n   *          cache: 14,\n   *        },\n   *      ],\n   *    },\n   *    fragmentRegistry: {\n   *      findFragmentSpreads: 34,\n   *      lookup: 20,\n   *      transform: 14,\n   *    },\n   *    cache: {\n   *      fragmentQueryDocuments: 22,\n   *    },\n   *    inMemoryCache: {\n   *      executeSelectionSet: 4345,\n   *      executeSubSelectedArray: 1206,\n   *      maybeBroadcastWatch: 32,\n   *    },\n   *    links: [\n   *      {\n   *        PersistedQueryLink: {\n   *          persistedQueryHashes: 14,\n   *        },\n   *      },\n   *      {\n   *        removeTypenameFromVariables: {\n   *          getVariableDefinitions: 14,\n   *        },\n   *      },\n   *    ],\n   *  },\n   * }\n   *```\n   */\n  public getMemoryInternals?: typeof getApolloClientMemoryInternals;\n}\n\nif (__DEV__) {\n  ApolloClient.prototype.getMemoryInternals = getApolloClientMemoryInternals;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}